# Whale-of-Fortune-v0
Initial attempt at creating a Smart Contract for the Whale of Fortune game on Kujira 

# Description 
The contract defines a simple betting game called "Whale of Fortune". In this game, players place bets on a number between 0 and 9, and a random number is generated using a trusted third-party oracle service called an "entropy beacon". If the player's chosen number matches one of the digits in the randomly generated number, they win the game and receive a payout.

The contract consists of four main parts: the msg module, which defines the different messages that can be sent to the contract; the state module, which defines the state of the contract and the Game struct; the helpers module, which provides a helper function for interacting with the contract; and the contract module, which defines the contract's business logic.

The Game struct represents a single game played by a player. It contains information such as the player's address, the amount they bet, the random number generated by the entropy beacon, and the result of the game (i.e., whether the player won or lost).

The contract module defines the business logic of the contract. It includes several functions that can be called by players to place bets, check the results of a game, and claim their winnings. The most important function is execute, which is called when a player sends a ExecuteMsg to the contract. This function checks the validity of the message, generates a random number using the entropy beacon, and updates the state of the contract to reflect the outcome of the game.

When a player places a bet, the execute function creates a new Game struct and stores it in the contract's state. If the player wins the game, they receive a payout, which is calculated based on the odds of winning and the amount of their bet.

To ensure fairness and transparency, the entropy beacon used by the contract must be provided by a trusted third-party service. This is important because the randomness of the generated number is critical to the outcome of the game. If the entropy beacon were to be compromised or manipulated, the game could be rigged in favor of certain players.

Overall, the contract is designed to be simple and transparent, with a clear set of rules and a fair game-play mechanism. It provides players with a fun and exciting way to gamble their crypto assets, while minimizing the risk of fraud or exploitation.

# Files 
In msg.rs, we define the various messages that can be passed to the contract. The InstantiateMsg is used to initialize the game state, and the ExecuteMsg is used to execute game moves or query the state of the game.

In state.rs, we define the game state in the form of the Game struct. The struct has fields that represent the game's state, including the player, bet amount, result, and payout. There is also a win method that checks if the player's bet matches the outcome generated by the entropy beacon.

In error.rs, we define the various errors that can occur during contract execution.

In contract.rs, we implement the smart contract's core functionality, including its initialization and execution logic. The instantiate function initializes the game state by accepting the entropy beacon's initial value and the player's bet. The execute function accepts the player's guess and determines if it matches the entropy beacon's outcome. If it does, the player wins and receives a payout. Otherwise, the player loses their bet. The query function is used to retrieve the current game state.

In helpers.rs, we define the CwTemplateContract struct, which is a wrapper around Addr that provides helpers for working with the contract.

The contract follows the Cosmos SDK specification, which defines a standard way of interacting with blockchain-based applications. It uses the CosmWasm smart contract framework, which provides a number of utility functions for smart contract development.
